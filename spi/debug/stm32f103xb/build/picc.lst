ARM GAS  /tmp/cc7qBfpH.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 6
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"picc.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.PICC_RequestA,"ax",%progbits
  16              		.align	1
  17              		.global	PICC_RequestA
  18              		.arch armv7-m
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu softvfp
  24              	PICC_RequestA:
  25              	.LFB0:
  26              		.file 1 "../../lib/bsrfid/cards/picc.c"
   1:../../lib/bsrfid/cards/picc.c **** /*
   2:../../lib/bsrfid/cards/picc.c ****  * picc.c
   3:../../lib/bsrfid/cards/picc.c ****  *
   4:../../lib/bsrfid/cards/picc.c ****  *  Created on: 29 dec. 2020
   5:../../lib/bsrfid/cards/picc.c ****  *      Author: andre
   6:../../lib/bsrfid/cards/picc.c ****  */
   7:../../lib/bsrfid/cards/picc.c **** 
   8:../../lib/bsrfid/cards/picc.c **** #include "picc.h"
   9:../../lib/bsrfid/cards/picc.c **** #include "pdc.h"
  10:../../lib/bsrfid/cards/picc.c **** 
  11:../../lib/bsrfid/cards/picc.c **** /**
  12:../../lib/bsrfid/cards/picc.c ****  * Transmits a REQuest command, Type A. Invites PICCs in state IDLE to go to READY and prepare for 
  13:../../lib/bsrfid/cards/picc.c ****  * Beware: When two PICCs are in the field at the same time I often get STATUS_TIMEOUT - probably d
  14:../../lib/bsrfid/cards/picc.c ****  *
  15:../../lib/bsrfid/cards/picc.c ****  * @return STATUS_OK on success, STATUS_??? otherwise.
  16:../../lib/bsrfid/cards/picc.c ****  */
  17:../../lib/bsrfid/cards/picc.c **** rc52x_result_t PICC_RequestA(bs_pdc_t *pdc, picc_t *picc) {
  27              		.loc 1 17 59
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 16
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31 0000 80B5     		push	{r7, lr}
  32              		.cfi_def_cfa_offset 8
  33              		.cfi_offset 7, -8
  34              		.cfi_offset 14, -4
  35 0002 84B0     		sub	sp, sp, #16
  36              		.cfi_def_cfa_offset 24
  37 0004 00AF     		add	r7, sp, #0
  38              		.cfi_def_cfa_register 7
  39 0006 7860     		str	r0, [r7, #4]
  40 0008 3960     		str	r1, [r7]
  18:../../lib/bsrfid/cards/picc.c **** 	picc->protocol = picc_protocol_iso14443a;
ARM GAS  /tmp/cc7qBfpH.s 			page 2


  41              		.loc 1 18 17
  42 000a 3B68     		ldr	r3, [r7]
  43 000c 0122     		movs	r2, #1
  44 000e 1A70     		strb	r2, [r3]
  19:../../lib/bsrfid/cards/picc.c **** 	size_t size = sizeof(iso14443a_atqa_t);
  45              		.loc 1 19 9
  46 0010 0223     		movs	r3, #2
  47 0012 FB60     		str	r3, [r7, #12]
  20:../../lib/bsrfid/cards/picc.c **** 	return PICC_REQA_or_WUPA(pdc, PICC_CMD_REQA, &picc->atqa, &size);
  48              		.loc 1 20 47
  49 0014 3B68     		ldr	r3, [r7]
  50 0016 03F10E02 		add	r2, r3, #14
  51              		.loc 1 20 9
  52 001a 07F10C03 		add	r3, r7, #12
  53 001e 2621     		movs	r1, #38
  54 0020 7868     		ldr	r0, [r7, #4]
  55 0022 FFF7FEFF 		bl	PICC_REQA_or_WUPA
  56 0026 0346     		mov	r3, r0
  21:../../lib/bsrfid/cards/picc.c **** } // End PICC_RequestA()
  57              		.loc 1 21 1
  58 0028 1846     		mov	r0, r3
  59 002a 1037     		adds	r7, r7, #16
  60              		.cfi_def_cfa_offset 8
  61 002c BD46     		mov	sp, r7
  62              		.cfi_def_cfa_register 13
  63              		@ sp needed
  64 002e 80BD     		pop	{r7, pc}
  65              		.cfi_endproc
  66              	.LFE0:
  68              		.section	.text.PICC_WakeupA,"ax",%progbits
  69              		.align	1
  70              		.global	PICC_WakeupA
  71              		.syntax unified
  72              		.thumb
  73              		.thumb_func
  74              		.fpu softvfp
  76              	PICC_WakeupA:
  77              	.LFB1:
  22:../../lib/bsrfid/cards/picc.c **** 
  23:../../lib/bsrfid/cards/picc.c **** /**
  24:../../lib/bsrfid/cards/picc.c ****  * Transmits a Wake-UP command, Type A. Invites PICCs in state IDLE and HALT to go to READY(*) and 
  25:../../lib/bsrfid/cards/picc.c ****  * Beware: When two PICCs are in the field at the same time I often get STATUS_TIMEOUT - probably d
  26:../../lib/bsrfid/cards/picc.c ****  *
  27:../../lib/bsrfid/cards/picc.c ****  * @return STATUS_OK on success, STATUS_??? otherwise.
  28:../../lib/bsrfid/cards/picc.c ****  */
  29:../../lib/bsrfid/cards/picc.c **** rc52x_result_t PICC_WakeupA(bs_pdc_t *pdc, picc_t *picc) {
  78              		.loc 1 29 58
  79              		.cfi_startproc
  80              		@ args = 0, pretend = 0, frame = 16
  81              		@ frame_needed = 1, uses_anonymous_args = 0
  82 0000 80B5     		push	{r7, lr}
  83              		.cfi_def_cfa_offset 8
  84              		.cfi_offset 7, -8
  85              		.cfi_offset 14, -4
  86 0002 84B0     		sub	sp, sp, #16
  87              		.cfi_def_cfa_offset 24
  88 0004 00AF     		add	r7, sp, #0
ARM GAS  /tmp/cc7qBfpH.s 			page 3


  89              		.cfi_def_cfa_register 7
  90 0006 7860     		str	r0, [r7, #4]
  91 0008 3960     		str	r1, [r7]
  30:../../lib/bsrfid/cards/picc.c **** 	if (picc->protocol != picc_protocol_iso14443a)
  92              		.loc 1 30 10
  93 000a 3B68     		ldr	r3, [r7]
  94 000c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
  95              		.loc 1 30 5
  96 000e 012B     		cmp	r3, #1
  97 0010 02D0     		beq	.L4
  31:../../lib/bsrfid/cards/picc.c **** 		return STATUS_INVALID;
  98              		.loc 1 31 10
  99 0012 6FF00603 		mvn	r3, #6
 100 0016 0BE0     		b	.L6
 101              	.L4:
  32:../../lib/bsrfid/cards/picc.c **** 	size_t size = sizeof(iso14443a_atqa_t);
 102              		.loc 1 32 9
 103 0018 0223     		movs	r3, #2
 104 001a FB60     		str	r3, [r7, #12]
  33:../../lib/bsrfid/cards/picc.c **** 	return PICC_REQA_or_WUPA(pdc, PICC_CMD_WUPA, &picc->atqa, &size);
 105              		.loc 1 33 47
 106 001c 3B68     		ldr	r3, [r7]
 107 001e 03F10E02 		add	r2, r3, #14
 108              		.loc 1 33 9
 109 0022 07F10C03 		add	r3, r7, #12
 110 0026 5221     		movs	r1, #82
 111 0028 7868     		ldr	r0, [r7, #4]
 112 002a FFF7FEFF 		bl	PICC_REQA_or_WUPA
 113 002e 0346     		mov	r3, r0
 114              	.L6:
  34:../../lib/bsrfid/cards/picc.c **** } //  // End PICC_WakeupA()
 115              		.loc 1 34 1 discriminator 1
 116 0030 1846     		mov	r0, r3
 117 0032 1037     		adds	r7, r7, #16
 118              		.cfi_def_cfa_offset 8
 119 0034 BD46     		mov	sp, r7
 120              		.cfi_def_cfa_register 13
 121              		@ sp needed
 122 0036 80BD     		pop	{r7, pc}
 123              		.cfi_endproc
 124              	.LFE1:
 126              		.section	.text.PICC_REQA_or_WUPA,"ax",%progbits
 127              		.align	1
 128              		.global	PICC_REQA_or_WUPA
 129              		.syntax unified
 130              		.thumb
 131              		.thumb_func
 132              		.fpu softvfp
 134              	PICC_REQA_or_WUPA:
 135              	.LFB2:
  35:../../lib/bsrfid/cards/picc.c **** 
  36:../../lib/bsrfid/cards/picc.c **** /**
  37:../../lib/bsrfid/cards/picc.c ****  * Transmits REQA or WUPA commands.
  38:../../lib/bsrfid/cards/picc.c ****  * Beware: When two PICCs are in the field at the same time I often get STATUS_TIMEOUT - probably d
  39:../../lib/bsrfid/cards/picc.c ****  *
  40:../../lib/bsrfid/cards/picc.c ****  * @return STATUS_OK on success, STATUS_??? otherwise.
  41:../../lib/bsrfid/cards/picc.c ****  */
ARM GAS  /tmp/cc7qBfpH.s 			page 4


  42:../../lib/bsrfid/cards/picc.c **** rc52x_result_t PICC_REQA_or_WUPA(bs_pdc_t *pdc, uint8_t command, ///< The command to send - PICC_CM
  43:../../lib/bsrfid/cards/picc.c **** 		uint8_t *bufferATQA, ///< The buffer to store the ATQA (Answer to request) in
  44:../../lib/bsrfid/cards/picc.c **** 		size_t *bufferSize///< Buffer size, at least two bytes. Also number of bytes returned if STATUS_O
  45:../../lib/bsrfid/cards/picc.c **** 		) {
 136              		.loc 1 45 5
 137              		.cfi_startproc
 138              		@ args = 0, pretend = 0, frame = 24
 139              		@ frame_needed = 1, uses_anonymous_args = 0
 140 0000 90B5     		push	{r4, r7, lr}
 141              		.cfi_def_cfa_offset 12
 142              		.cfi_offset 4, -12
 143              		.cfi_offset 7, -8
 144              		.cfi_offset 14, -4
 145 0002 8DB0     		sub	sp, sp, #52
 146              		.cfi_def_cfa_offset 64
 147 0004 06AF     		add	r7, sp, #24
 148              		.cfi_def_cfa 7, 40
 149 0006 F860     		str	r0, [r7, #12]
 150 0008 7A60     		str	r2, [r7, #4]
 151 000a 3B60     		str	r3, [r7]
 152 000c 0B46     		mov	r3, r1
 153 000e FB72     		strb	r3, [r7, #11]
  46:../../lib/bsrfid/cards/picc.c **** 	uint8_t validBits;
  47:../../lib/bsrfid/cards/picc.c **** 	rc52x_result_t status;
  48:../../lib/bsrfid/cards/picc.c **** 
  49:../../lib/bsrfid/cards/picc.c **** 	if (bufferATQA == NULL || *bufferSize < 2) {// The ATQA response is 2 bytes long.
 154              		.loc 1 49 5
 155 0010 7B68     		ldr	r3, [r7, #4]
 156 0012 002B     		cmp	r3, #0
 157 0014 03D0     		beq	.L8
 158              		.loc 1 49 28 discriminator 1
 159 0016 3B68     		ldr	r3, [r7]
 160 0018 1B68     		ldr	r3, [r3]
 161              		.loc 1 49 25 discriminator 1
 162 001a 012B     		cmp	r3, #1
 163 001c 02D8     		bhi	.L9
 164              	.L8:
  50:../../lib/bsrfid/cards/picc.c **** 		return STATUS_NO_ROOM;
 165              		.loc 1 50 10
 166 001e 6FF00403 		mvn	r3, #4
 167 0022 2AE0     		b	.L14
 168              	.L9:
  51:../../lib/bsrfid/cards/picc.c **** 	}
  52:../../lib/bsrfid/cards/picc.c **** 
  53:../../lib/bsrfid/cards/picc.c **** 	// Do we need to keep this into the port?
  54:../../lib/bsrfid/cards/picc.c **** 	//RC52X_ClearRegisterBitMask(rc52x, RC52X_REG_CollReg, 0x80);// ValuesAfterColl=1 => Bits received
  55:../../lib/bsrfid/cards/picc.c **** 
  56:../../lib/bsrfid/cards/picc.c **** 	validBits = 7;// For REQA and WUPA we need the short frame format - transmit only 7 bits of the la
 169              		.loc 1 56 12
 170 0024 0723     		movs	r3, #7
 171 0026 BB75     		strb	r3, [r7, #22]
  57:../../lib/bsrfid/cards/picc.c **** 
  58:../../lib/bsrfid/cards/picc.c **** 
  59:../../lib/bsrfid/cards/picc.c **** 	status = pdc->TransceiveData(pdc, &command, 1, bufferATQA, bufferSize,
 172              		.loc 1 59 14
 173 0028 FB68     		ldr	r3, [r7, #12]
 174 002a DC68     		ldr	r4, [r3, #12]
ARM GAS  /tmp/cc7qBfpH.s 			page 5


 175              		.loc 1 59 11
 176 002c 07F10B01 		add	r1, r7, #11
 177 0030 0023     		movs	r3, #0
 178 0032 0593     		str	r3, [sp, #20]
 179 0034 0023     		movs	r3, #0
 180 0036 0493     		str	r3, [sp, #16]
 181 0038 0023     		movs	r3, #0
 182 003a 0393     		str	r3, [sp, #12]
 183 003c 0023     		movs	r3, #0
 184 003e 0293     		str	r3, [sp, #8]
 185 0040 07F11603 		add	r3, r7, #22
 186 0044 0193     		str	r3, [sp, #4]
 187 0046 3B68     		ldr	r3, [r7]
 188 0048 0093     		str	r3, [sp]
 189 004a 7B68     		ldr	r3, [r7, #4]
 190 004c 0122     		movs	r2, #1
 191 004e F868     		ldr	r0, [r7, #12]
 192 0050 A047     		blx	r4
 193              	.LVL0:
 194 0052 0346     		mov	r3, r0
 195              		.loc 1 59 9
 196 0054 FB75     		strb	r3, [r7, #23]
  60:../../lib/bsrfid/cards/picc.c **** 			&validBits, 0, NULL, false, false);
  61:../../lib/bsrfid/cards/picc.c **** 	//status = RC52X_TransceiveData(rc52x, &command, 1, bufferATQA, bufferSize, &validBits, 0, false);
  62:../../lib/bsrfid/cards/picc.c **** 	if (status != STATUS_OK) {
 197              		.loc 1 62 5
 198 0056 97F91730 		ldrsb	r3, [r7, #23]
 199 005a 002B     		cmp	r3, #0
 200 005c 02D0     		beq	.L11
  63:../../lib/bsrfid/cards/picc.c **** 		return status;
 201              		.loc 1 63 10
 202 005e 97F91730 		ldrsb	r3, [r7, #23]
 203 0062 0AE0     		b	.L14
 204              	.L11:
  64:../../lib/bsrfid/cards/picc.c **** 	}
  65:../../lib/bsrfid/cards/picc.c **** 	if (*bufferSize != 2 || validBits != 0) {	// ATQA must be exactly 16 bits.
 205              		.loc 1 65 6
 206 0064 3B68     		ldr	r3, [r7]
 207 0066 1B68     		ldr	r3, [r3]
 208              		.loc 1 65 5
 209 0068 022B     		cmp	r3, #2
 210 006a 02D1     		bne	.L12
 211              		.loc 1 65 36 discriminator 1
 212 006c BB7D     		ldrb	r3, [r7, #22]	@ zero_extendqisi2
 213              		.loc 1 65 23 discriminator 1
 214 006e 002B     		cmp	r3, #0
 215 0070 02D0     		beq	.L13
 216              	.L12:
  66:../../lib/bsrfid/cards/picc.c **** 		return STATUS_ERROR;
 217              		.loc 1 66 10
 218 0072 4FF0FF33 		mov	r3, #-1
 219 0076 00E0     		b	.L14
 220              	.L13:
  67:../../lib/bsrfid/cards/picc.c **** 	}
  68:../../lib/bsrfid/cards/picc.c **** 	return STATUS_OK;
 221              		.loc 1 68 9
 222 0078 0023     		movs	r3, #0
ARM GAS  /tmp/cc7qBfpH.s 			page 6


 223              	.L14:
  69:../../lib/bsrfid/cards/picc.c **** } // End PICC_REQA_or_WUPA()
 224              		.loc 1 69 1 discriminator 1
 225 007a 1846     		mov	r0, r3
 226 007c 1C37     		adds	r7, r7, #28
 227              		.cfi_def_cfa_offset 12
 228 007e BD46     		mov	sp, r7
 229              		.cfi_def_cfa_register 13
 230              		@ sp needed
 231 0080 90BD     		pop	{r4, r7, pc}
 232              		.cfi_endproc
 233              	.LFE2:
 235              		.section	.text.PICC_Select,"ax",%progbits
 236              		.align	1
 237              		.global	PICC_Select
 238              		.syntax unified
 239              		.thumb
 240              		.thumb_func
 241              		.fpu softvfp
 243              	PICC_Select:
 244              	.LFB3:
  70:../../lib/bsrfid/cards/picc.c **** 
  71:../../lib/bsrfid/cards/picc.c **** /**
  72:../../lib/bsrfid/cards/picc.c ****  * Transmits SELECT/ANTICOLLISION commands to select a single PICC.
  73:../../lib/bsrfid/cards/picc.c ****  * Before calling this function the PICCs must be placed in the READY(*) state by calling PICC_Requ
  74:../../lib/bsrfid/cards/picc.c ****  * On success:
  75:../../lib/bsrfid/cards/picc.c ****  * 		- The chosen PICC is in state ACTIVE(*) and all other PICCs have returned to state IDLE/HALT. 
  76:../../lib/bsrfid/cards/picc.c ****  * 		- The UID size and value of the chosen PICC is returned in *uid along with the SAK.
  77:../../lib/bsrfid/cards/picc.c ****  *
  78:../../lib/bsrfid/cards/picc.c ****  * A PICC UID consists of 4, 7 or 10 bytes.
  79:../../lib/bsrfid/cards/picc.c ****  * Only 4 uint8_ts can be specified in a SELECT command, so for the longer UIDs two or three iterat
  80:../../lib/bsrfid/cards/picc.c ****  * 		UID size	Number of UID uint8_ts		Cascade levels		Example of PICC
  81:../../lib/bsrfid/cards/picc.c ****  * 		========	===================		==============		===============
  82:../../lib/bsrfid/cards/picc.c ****  * 		single				 4						1				MIFARE Classic
  83:../../lib/bsrfid/cards/picc.c ****  * 		double				 7						2				MIFARE Ultralight
  84:../../lib/bsrfid/cards/picc.c ****  * 		triple				10						3				Not currently in use?
  85:../../lib/bsrfid/cards/picc.c ****  *
  86:../../lib/bsrfid/cards/picc.c ****  *
  87:../../lib/bsrfid/cards/picc.c ****  * uid:  Pointer to Uid struct. Normally output, but can also be used to supply a known UID.
  88:../../lib/bsrfid/cards/picc.c ****  * validBits: The number of known UID bits supplied in *uid. Normally 0. If set you must also suppl
  89:../../lib/bsrfid/cards/picc.c ****  *
  90:../../lib/bsrfid/cards/picc.c ****  * @return STATUS_OK on success, STATUS_??? otherwise.
  91:../../lib/bsrfid/cards/picc.c ****  */
  92:../../lib/bsrfid/cards/picc.c **** rc52x_result_t PICC_Select(bs_pdc_t *pdc, picc_t *picc, uint8_t validBits) {
 245              		.loc 1 92 76
 246              		.cfi_startproc
 247              		@ args = 0, pretend = 0, frame = 64
 248              		@ frame_needed = 1, uses_anonymous_args = 0
 249 0000 90B5     		push	{r4, r7, lr}
 250              		.cfi_def_cfa_offset 12
 251              		.cfi_offset 4, -12
 252              		.cfi_offset 7, -8
 253              		.cfi_offset 14, -4
 254 0002 97B0     		sub	sp, sp, #92
 255              		.cfi_def_cfa_offset 104
 256 0004 06AF     		add	r7, sp, #24
 257              		.cfi_def_cfa 7, 80
ARM GAS  /tmp/cc7qBfpH.s 			page 7


 258 0006 F860     		str	r0, [r7, #12]
 259 0008 B960     		str	r1, [r7, #8]
 260 000a 1346     		mov	r3, r2
 261 000c FB71     		strb	r3, [r7, #7]
  93:../../lib/bsrfid/cards/picc.c **** 	bool uidComplete;
  94:../../lib/bsrfid/cards/picc.c **** 	bool selectDone;
  95:../../lib/bsrfid/cards/picc.c **** 	bool useCascadeTag;
  96:../../lib/bsrfid/cards/picc.c **** 	uint8_t cascadeLevel = 1;
 262              		.loc 1 96 10
 263 000e 0123     		movs	r3, #1
 264 0010 87F83C30 		strb	r3, [r7, #60]
  97:../../lib/bsrfid/cards/picc.c **** 	rc52x_result_t result;
  98:../../lib/bsrfid/cards/picc.c **** 	uint8_t count;
  99:../../lib/bsrfid/cards/picc.c **** 	uint8_t checkBit;
 100:../../lib/bsrfid/cards/picc.c **** 	uint8_t index;
 101:../../lib/bsrfid/cards/picc.c **** 	uint8_t uidIndex; // The first index in uid->uidByte[] that is used in the current Cascade Level.
 102:../../lib/bsrfid/cards/picc.c **** 	int8_t currentLevelKnownBits; // The number of known UID bits in the current Cascade Level.
 103:../../lib/bsrfid/cards/picc.c **** 	uint8_t buffer[9]; // The SELECT/ANTICOLLISION commands uses a 7 uint8_t standard frame + 2 uint8_
 104:../../lib/bsrfid/cards/picc.c **** 	uint8_t bufferUsed;	// The number of uint8_ts used in the buffer, ie the number of uint8_ts to tra
 105:../../lib/bsrfid/cards/picc.c **** 	uint8_t rxAlign;// Used in BitFramingReg. Defines the bit position for the first bit received.
 106:../../lib/bsrfid/cards/picc.c **** 	uint8_t txLastBits;	// Used in BitFramingReg. The number of valid bits in the last transmitted uin
 107:../../lib/bsrfid/cards/picc.c **** 	uint8_t *responseBuffer;
 108:../../lib/bsrfid/cards/picc.c **** 	size_t responseLength;
 109:../../lib/bsrfid/cards/picc.c **** 	bool sendCRC;
 110:../../lib/bsrfid/cards/picc.c **** 
 111:../../lib/bsrfid/cards/picc.c **** 	// Description of buffer structure:
 112:../../lib/bsrfid/cards/picc.c **** 	//		uint8_t 0: SEL 				Indicates the Cascade Level: PICC_CMD_SEL_CL1, PICC_CMD_SEL_CL2 or PICC_CMD
 113:../../lib/bsrfid/cards/picc.c **** 	//		uint8_t 1: NVB					Number of Valid Bits (in complete command, not just the UID): High nibble: 
 114:../../lib/bsrfid/cards/picc.c **** 	//		uint8_t 2: UID-data or CT		See explanation below. CT means Cascade Tag.
 115:../../lib/bsrfid/cards/picc.c **** 	//		uint8_t 3: UID-data
 116:../../lib/bsrfid/cards/picc.c **** 	//		uint8_t 4: UID-data
 117:../../lib/bsrfid/cards/picc.c **** 	//		uint8_t 5: UID-data
 118:../../lib/bsrfid/cards/picc.c **** 	//		uint8_t 6: BCC					Block Check Character - XOR of uint8_ts 2-5
 119:../../lib/bsrfid/cards/picc.c **** 	//		uint8_t 7: CRC_A
 120:../../lib/bsrfid/cards/picc.c **** 	//		uint8_t 8: CRC_A
 121:../../lib/bsrfid/cards/picc.c **** 	// The BCC and CRC_A are only transmitted if we know all the UID bits of the current Cascade Level
 122:../../lib/bsrfid/cards/picc.c **** 	//
 123:../../lib/bsrfid/cards/picc.c **** 	// Description of uint8_ts 2-5: (Section 6.5.4 of the ISO/IEC 14443-3 draft: UID contents and casc
 124:../../lib/bsrfid/cards/picc.c **** 	//		UID size	Cascade level	uint8_t2	uint8_t3	uint8_t4	uint8_t5
 125:../../lib/bsrfid/cards/picc.c **** 	//		========	=============	=====	=====	=====	=====
 126:../../lib/bsrfid/cards/picc.c **** 	//		 4 uint8_ts		1			uid0	uid1	uid2	uid3
 127:../../lib/bsrfid/cards/picc.c **** 	//		 7 uint8_ts		1			CT		uid0	uid1	uid2
 128:../../lib/bsrfid/cards/picc.c **** 	//						2			uid3	uid4	uid5	uid6
 129:../../lib/bsrfid/cards/picc.c **** 	//		10 uint8_ts		1			CT		uid0	uid1	uid2
 130:../../lib/bsrfid/cards/picc.c **** 	//						2			CT		uid3	uid4	uid5
 131:../../lib/bsrfid/cards/picc.c **** 	//						3			uid6	uid7	uid8	uid9
 132:../../lib/bsrfid/cards/picc.c **** 
 133:../../lib/bsrfid/cards/picc.c **** 	// Sanity checks
 134:../../lib/bsrfid/cards/picc.c **** 	if (validBits > 80) {
 265              		.loc 1 134 5
 266 0014 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 267 0016 502B     		cmp	r3, #80
 268 0018 02D9     		bls	.L16
 135:../../lib/bsrfid/cards/picc.c **** 		return STATUS_INVALID;
 269              		.loc 1 135 10
 270 001a 6FF00603 		mvn	r3, #6
 271 001e 1FE2     		b	.L60
ARM GAS  /tmp/cc7qBfpH.s 			page 8


 272              	.L16:
 136:../../lib/bsrfid/cards/picc.c **** 	}
 137:../../lib/bsrfid/cards/picc.c **** 
 138:../../lib/bsrfid/cards/picc.c **** 	// Prepare MFRC522
 139:../../lib/bsrfid/cards/picc.c **** 	// TODO
 140:../../lib/bsrfid/cards/picc.c **** 	//RC52X_ClearRegisterBitMask(rc52x, RC52X_REG_CollReg, 0x80);// ValuesAfterColl=1 => Bits received
 141:../../lib/bsrfid/cards/picc.c **** 
 142:../../lib/bsrfid/cards/picc.c **** 	// Repeat Cascade Level loop until we have a complete UID.
 143:../../lib/bsrfid/cards/picc.c **** 	uidComplete = false;
 273              		.loc 1 143 14
 274 0020 0023     		movs	r3, #0
 275 0022 87F83F30 		strb	r3, [r7, #63]
 144:../../lib/bsrfid/cards/picc.c **** 	while (!uidComplete) {
 276              		.loc 1 144 8
 277 0026 08E2     		b	.L18
 278              	.L59:
 279              	.LBB2:
 145:../../lib/bsrfid/cards/picc.c **** 		// Set the Cascade Level in the SEL uint8_t, find out if we need to use the Cascade Tag in uint8_
 146:../../lib/bsrfid/cards/picc.c **** 		switch (cascadeLevel) {
 280              		.loc 1 146 3
 281 0028 97F83C30 		ldrb	r3, [r7, #60]	@ zero_extendqisi2
 282 002c 032B     		cmp	r3, #3
 283 002e 38D0     		beq	.L19
 284 0030 032B     		cmp	r3, #3
 285 0032 40DC     		bgt	.L20
 286 0034 012B     		cmp	r3, #1
 287 0036 02D0     		beq	.L21
 288 0038 022B     		cmp	r3, #2
 289 003a 19D0     		beq	.L22
 290 003c 3BE0     		b	.L20
 291              	.L21:
 147:../../lib/bsrfid/cards/picc.c **** 		case 1:
 148:../../lib/bsrfid/cards/picc.c **** 			buffer[0] = PICC_CMD_SEL_CL1;
 292              		.loc 1 148 14
 293 003e 9323     		movs	r3, #147
 294 0040 87F82030 		strb	r3, [r7, #32]
 149:../../lib/bsrfid/cards/picc.c **** 			uidIndex = 0;
 295              		.loc 1 149 13
 296 0044 0023     		movs	r3, #0
 297 0046 87F83930 		strb	r3, [r7, #57]
 150:../../lib/bsrfid/cards/picc.c **** 			useCascadeTag = validBits && picc->size > 4;// When we know that the UID has more than 4 uint8_t
 298              		.loc 1 150 30
 299 004a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 300 004c 002B     		cmp	r3, #0
 301 004e 05D0     		beq	.L23
 302              		.loc 1 150 37 discriminator 1
 303 0050 BB68     		ldr	r3, [r7, #8]
 304 0052 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 305              		.loc 1 150 30 discriminator 1
 306 0054 042B     		cmp	r3, #4
 307 0056 01D9     		bls	.L23
 308              		.loc 1 150 30 is_stmt 0 discriminator 3
 309 0058 0123     		movs	r3, #1
 310 005a 00E0     		b	.L24
 311              	.L23:
 312              		.loc 1 150 30 discriminator 4
 313 005c 0023     		movs	r3, #0
ARM GAS  /tmp/cc7qBfpH.s 			page 9


 314              	.L24:
 315              		.loc 1 150 18 is_stmt 1 discriminator 6
 316 005e 87F83D30 		strb	r3, [r7, #61]
 317 0062 97F83D30 		ldrb	r3, [r7, #61]
 318 0066 03F00103 		and	r3, r3, #1
 319 006a 87F83D30 		strb	r3, [r7, #61]
 151:../../lib/bsrfid/cards/picc.c **** 			break;
 320              		.loc 1 151 4 discriminator 6
 321 006e 25E0     		b	.L25
 322              	.L22:
 152:../../lib/bsrfid/cards/picc.c **** 
 153:../../lib/bsrfid/cards/picc.c **** 		case 2:
 154:../../lib/bsrfid/cards/picc.c **** 			buffer[0] = PICC_CMD_SEL_CL2;
 323              		.loc 1 154 14
 324 0070 9523     		movs	r3, #149
 325 0072 87F82030 		strb	r3, [r7, #32]
 155:../../lib/bsrfid/cards/picc.c **** 			uidIndex = 3;
 326              		.loc 1 155 13
 327 0076 0323     		movs	r3, #3
 328 0078 87F83930 		strb	r3, [r7, #57]
 156:../../lib/bsrfid/cards/picc.c **** 			useCascadeTag = validBits && picc->size > 7;// When we know that the UID has more than 7 uint8_t
 329              		.loc 1 156 30
 330 007c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 331 007e 002B     		cmp	r3, #0
 332 0080 05D0     		beq	.L26
 333              		.loc 1 156 37 discriminator 1
 334 0082 BB68     		ldr	r3, [r7, #8]
 335 0084 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 336              		.loc 1 156 30 discriminator 1
 337 0086 072B     		cmp	r3, #7
 338 0088 01D9     		bls	.L26
 339              		.loc 1 156 30 is_stmt 0 discriminator 3
 340 008a 0123     		movs	r3, #1
 341 008c 00E0     		b	.L27
 342              	.L26:
 343              		.loc 1 156 30 discriminator 4
 344 008e 0023     		movs	r3, #0
 345              	.L27:
 346              		.loc 1 156 18 is_stmt 1 discriminator 6
 347 0090 87F83D30 		strb	r3, [r7, #61]
 348 0094 97F83D30 		ldrb	r3, [r7, #61]
 349 0098 03F00103 		and	r3, r3, #1
 350 009c 87F83D30 		strb	r3, [r7, #61]
 157:../../lib/bsrfid/cards/picc.c **** 			break;
 351              		.loc 1 157 4 discriminator 6
 352 00a0 0CE0     		b	.L25
 353              	.L19:
 158:../../lib/bsrfid/cards/picc.c **** 
 159:../../lib/bsrfid/cards/picc.c **** 		case 3:
 160:../../lib/bsrfid/cards/picc.c **** 			buffer[0] = PICC_CMD_SEL_CL3;
 354              		.loc 1 160 14
 355 00a2 9723     		movs	r3, #151
 356 00a4 87F82030 		strb	r3, [r7, #32]
 161:../../lib/bsrfid/cards/picc.c **** 			uidIndex = 6;
 357              		.loc 1 161 13
 358 00a8 0623     		movs	r3, #6
 359 00aa 87F83930 		strb	r3, [r7, #57]
ARM GAS  /tmp/cc7qBfpH.s 			page 10


 162:../../lib/bsrfid/cards/picc.c **** 			useCascadeTag = false;						// Never used in CL3.
 360              		.loc 1 162 18
 361 00ae 0023     		movs	r3, #0
 362 00b0 87F83D30 		strb	r3, [r7, #61]
 163:../../lib/bsrfid/cards/picc.c **** 			break;
 363              		.loc 1 163 4
 364 00b4 02E0     		b	.L25
 365              	.L20:
 164:../../lib/bsrfid/cards/picc.c **** 
 165:../../lib/bsrfid/cards/picc.c **** 		default:
 166:../../lib/bsrfid/cards/picc.c **** 			return STATUS_INTERNAL_ERROR;
 366              		.loc 1 166 11
 367 00b6 6FF00503 		mvn	r3, #5
 368 00ba D1E1     		b	.L60
 369              	.L25:
 167:../../lib/bsrfid/cards/picc.c **** 			break;
 168:../../lib/bsrfid/cards/picc.c **** 		}
 169:../../lib/bsrfid/cards/picc.c **** 
 170:../../lib/bsrfid/cards/picc.c **** 		// How many UID bits are known in this Cascade Level?
 171:../../lib/bsrfid/cards/picc.c **** 		currentLevelKnownBits = validBits - (8 * uidIndex);
 370              		.loc 1 171 37
 371 00bc 97F83930 		ldrb	r3, [r7, #57]
 372 00c0 DB00     		lsls	r3, r3, #3
 373 00c2 DBB2     		uxtb	r3, r3
 374 00c4 FA79     		ldrb	r2, [r7, #7]
 375 00c6 D31A     		subs	r3, r2, r3
 376 00c8 DBB2     		uxtb	r3, r3
 377              		.loc 1 171 25
 378 00ca 87F83830 		strb	r3, [r7, #56]
 172:../../lib/bsrfid/cards/picc.c **** 		if (currentLevelKnownBits < 0) {
 379              		.loc 1 172 6
 380 00ce 97F93830 		ldrsb	r3, [r7, #56]
 381 00d2 002B     		cmp	r3, #0
 382 00d4 02DA     		bge	.L28
 173:../../lib/bsrfid/cards/picc.c **** 			currentLevelKnownBits = 0;
 383              		.loc 1 173 26
 384 00d6 0023     		movs	r3, #0
 385 00d8 87F83830 		strb	r3, [r7, #56]
 386              	.L28:
 174:../../lib/bsrfid/cards/picc.c **** 		}
 175:../../lib/bsrfid/cards/picc.c **** 		// Copy the known bits from uid->uidByte[] to buffer[]
 176:../../lib/bsrfid/cards/picc.c **** 		index = 2; // destination index in buffer[]
 387              		.loc 1 176 9
 388 00dc 0223     		movs	r3, #2
 389 00de 87F83A30 		strb	r3, [r7, #58]
 177:../../lib/bsrfid/cards/picc.c **** 		if (useCascadeTag) {
 390              		.loc 1 177 6
 391 00e2 97F83D30 		ldrb	r3, [r7, #61]	@ zero_extendqisi2
 392 00e6 002B     		cmp	r3, #0
 393 00e8 09D0     		beq	.L29
 178:../../lib/bsrfid/cards/picc.c **** 			buffer[index++] = PICC_CMD_CT;
 394              		.loc 1 178 16
 395 00ea 97F83A30 		ldrb	r3, [r7, #58]	@ zero_extendqisi2
 396 00ee 5A1C     		adds	r2, r3, #1
 397 00f0 87F83A20 		strb	r2, [r7, #58]
 398              		.loc 1 178 20
 399 00f4 4033     		adds	r3, r3, #64
ARM GAS  /tmp/cc7qBfpH.s 			page 11


 400 00f6 3B44     		add	r3, r3, r7
 401 00f8 8822     		movs	r2, #136
 402 00fa 03F8202C 		strb	r2, [r3, #-32]
 403              	.L29:
 179:../../lib/bsrfid/cards/picc.c **** 		}
 180:../../lib/bsrfid/cards/picc.c **** 		uint8_t BytesToCopy = currentLevelKnownBits / 8
 181:../../lib/bsrfid/cards/picc.c **** 				+ (currentLevelKnownBits % 8 ? 1 : 0); // The number of uint8_ts needed to represent the known 
 404              		.loc 1 181 5
 405 00fe 97F93830 		ldrsb	r3, [r7, #56]
 406 0102 002B     		cmp	r3, #0
 407 0104 00DA     		bge	.L30
 408 0106 0733     		adds	r3, r3, #7
 409              	.L30:
 410 0108 DB10     		asrs	r3, r3, #3
 411 010a 5BB2     		sxtb	r3, r3
 412 010c DBB2     		uxtb	r3, r3
 413              		.loc 1 181 34
 414 010e 97F83820 		ldrb	r2, [r7, #56]	@ zero_extendqisi2
 415 0112 02F00702 		and	r2, r2, #7
 416 0116 D2B2     		uxtb	r2, r2
 417              		.loc 1 181 38
 418 0118 002A     		cmp	r2, #0
 419 011a 14BF     		ite	ne
 420 011c 0122     		movne	r2, #1
 421 011e 0022     		moveq	r2, #0
 422 0120 D2B2     		uxtb	r2, r2
 180:../../lib/bsrfid/cards/picc.c **** 				+ (currentLevelKnownBits % 8 ? 1 : 0); // The number of uint8_ts needed to represent the known 
 423              		.loc 1 180 11
 424 0122 1344     		add	r3, r3, r2
 425 0124 87F82E30 		strb	r3, [r7, #46]
 182:../../lib/bsrfid/cards/picc.c **** 		if (BytesToCopy) {
 426              		.loc 1 182 6
 427 0128 97F82E30 		ldrb	r3, [r7, #46]	@ zero_extendqisi2
 428 012c 002B     		cmp	r3, #0
 429 012e 34D0     		beq	.L31
 430              	.LBB3:
 183:../../lib/bsrfid/cards/picc.c **** 			uint8_t maxBytes = useCascadeTag ? 3 : 4; // Max 4 uint8_ts in each Cascade Level. Only 3 left i
 431              		.loc 1 183 12
 432 0130 97F83D30 		ldrb	r3, [r7, #61]	@ zero_extendqisi2
 433 0134 002B     		cmp	r3, #0
 434 0136 01D0     		beq	.L32
 435              		.loc 1 183 12 is_stmt 0 discriminator 1
 436 0138 0323     		movs	r3, #3
 437 013a 00E0     		b	.L33
 438              	.L32:
 439              		.loc 1 183 12 discriminator 2
 440 013c 0423     		movs	r3, #4
 441              	.L33:
 442              		.loc 1 183 12 discriminator 4
 443 013e 87F82D30 		strb	r3, [r7, #45]
 184:../../lib/bsrfid/cards/picc.c **** 			if (BytesToCopy > maxBytes) {
 444              		.loc 1 184 7 is_stmt 1 discriminator 4
 445 0142 97F82E20 		ldrb	r2, [r7, #46]	@ zero_extendqisi2
 446 0146 97F82D30 		ldrb	r3, [r7, #45]	@ zero_extendqisi2
 447 014a 9A42     		cmp	r2, r3
 448 014c 03D9     		bls	.L34
 185:../../lib/bsrfid/cards/picc.c **** 				BytesToCopy = maxBytes;
ARM GAS  /tmp/cc7qBfpH.s 			page 12


 449              		.loc 1 185 17
 450 014e 97F82D30 		ldrb	r3, [r7, #45]
 451 0152 87F82E30 		strb	r3, [r7, #46]
 452              	.L34:
 186:../../lib/bsrfid/cards/picc.c **** 			}
 187:../../lib/bsrfid/cards/picc.c **** 			for (count = 0; count < BytesToCopy; count++) {
 453              		.loc 1 187 15
 454 0156 0023     		movs	r3, #0
 455 0158 87F83B30 		strb	r3, [r7, #59]
 456              		.loc 1 187 4
 457 015c 17E0     		b	.L35
 458              	.L36:
 188:../../lib/bsrfid/cards/picc.c **** 				buffer[index++] = picc->uidByte[uidIndex + count];
 459              		.loc 1 188 46 discriminator 3
 460 015e 97F83920 		ldrb	r2, [r7, #57]	@ zero_extendqisi2
 461 0162 97F83B30 		ldrb	r3, [r7, #59]	@ zero_extendqisi2
 462 0166 1A44     		add	r2, r2, r3
 463              		.loc 1 188 17 discriminator 3
 464 0168 97F83A30 		ldrb	r3, [r7, #58]	@ zero_extendqisi2
 465 016c 591C     		adds	r1, r3, #1
 466 016e 87F83A10 		strb	r1, [r7, #58]
 467 0172 1946     		mov	r1, r3
 468              		.loc 1 188 36 discriminator 3
 469 0174 BB68     		ldr	r3, [r7, #8]
 470 0176 1344     		add	r3, r3, r2
 471 0178 9A78     		ldrb	r2, [r3, #2]	@ zero_extendqisi2
 472              		.loc 1 188 21 discriminator 3
 473 017a 01F14003 		add	r3, r1, #64
 474 017e 3B44     		add	r3, r3, r7
 475 0180 03F8202C 		strb	r2, [r3, #-32]
 187:../../lib/bsrfid/cards/picc.c **** 				buffer[index++] = picc->uidByte[uidIndex + count];
 476              		.loc 1 187 46 discriminator 3
 477 0184 97F83B30 		ldrb	r3, [r7, #59]	@ zero_extendqisi2
 478 0188 0133     		adds	r3, r3, #1
 479 018a 87F83B30 		strb	r3, [r7, #59]
 480              	.L35:
 187:../../lib/bsrfid/cards/picc.c **** 				buffer[index++] = picc->uidByte[uidIndex + count];
 481              		.loc 1 187 26 discriminator 1
 482 018e 97F83B20 		ldrb	r2, [r7, #59]	@ zero_extendqisi2
 483 0192 97F82E30 		ldrb	r3, [r7, #46]	@ zero_extendqisi2
 484 0196 9A42     		cmp	r2, r3
 485 0198 E1D3     		bcc	.L36
 486              	.L31:
 487              	.LBE3:
 189:../../lib/bsrfid/cards/picc.c **** 			}
 190:../../lib/bsrfid/cards/picc.c **** 		}
 191:../../lib/bsrfid/cards/picc.c **** 		// Now that the data has been copied we need to include the 8 bits in CT in currentLevelKnownBits
 192:../../lib/bsrfid/cards/picc.c **** 		if (useCascadeTag) {
 488              		.loc 1 192 6
 489 019a 97F83D30 		ldrb	r3, [r7, #61]	@ zero_extendqisi2
 490 019e 002B     		cmp	r3, #0
 491 01a0 05D0     		beq	.L37
 193:../../lib/bsrfid/cards/picc.c **** 			currentLevelKnownBits += 8;
 492              		.loc 1 193 26
 493 01a2 97F83830 		ldrb	r3, [r7, #56]	@ zero_extendqisi2
 494 01a6 0833     		adds	r3, r3, #8
 495 01a8 DBB2     		uxtb	r3, r3
ARM GAS  /tmp/cc7qBfpH.s 			page 13


 496 01aa 87F83830 		strb	r3, [r7, #56]
 497              	.L37:
 194:../../lib/bsrfid/cards/picc.c **** 		}
 195:../../lib/bsrfid/cards/picc.c **** 
 196:../../lib/bsrfid/cards/picc.c **** 		// Repeat anti collision loop until we can transmit all UID bits + BCC and receive a SAK - max 32
 197:../../lib/bsrfid/cards/picc.c **** 		selectDone = false;
 498              		.loc 1 197 14
 499 01ae 0023     		movs	r3, #0
 500 01b0 87F83E30 		strb	r3, [r7, #62]
 198:../../lib/bsrfid/cards/picc.c **** 		while (!selectDone) {
 501              		.loc 1 198 9
 502 01b4 E8E0     		b	.L38
 503              	.L49:
 504              	.LBB4:
 199:../../lib/bsrfid/cards/picc.c **** 			// Find out how many bits and uint8_ts to send and receive.
 200:../../lib/bsrfid/cards/picc.c **** 			if (currentLevelKnownBits >= 32) { // All UID bits in this Cascade Level are known. This is a SE
 505              		.loc 1 200 7
 506 01b6 97F93830 		ldrsb	r3, [r7, #56]
 507 01ba 1F2B     		cmp	r3, #31
 508 01bc 21DD     		ble	.L39
 201:../../lib/bsrfid/cards/picc.c **** 				//Serial.print(F("SELECT: currentLevelKnownBits=")); Serial.println(currentLevelKnownBits, DEC)
 202:../../lib/bsrfid/cards/picc.c **** 				buffer[1] = 0x70; // NVB - Number of Valid Bits: Seven whole uint8_ts
 509              		.loc 1 202 15
 510 01be 7023     		movs	r3, #112
 511 01c0 87F82130 		strb	r3, [r7, #33]
 203:../../lib/bsrfid/cards/picc.c **** 				// Calculate BCC - Block Check Character
 204:../../lib/bsrfid/cards/picc.c **** 				buffer[6] = buffer[2] ^ buffer[3] ^ buffer[4] ^ buffer[5];
 512              		.loc 1 204 23
 513 01c4 97F82220 		ldrb	r2, [r7, #34]	@ zero_extendqisi2
 514              		.loc 1 204 35
 515 01c8 97F82330 		ldrb	r3, [r7, #35]	@ zero_extendqisi2
 516              		.loc 1 204 15
 517 01cc 5340     		eors	r3, r3, r2
 518 01ce DAB2     		uxtb	r2, r3
 519              		.loc 1 204 47
 520 01d0 97F82430 		ldrb	r3, [r7, #36]	@ zero_extendqisi2
 521              		.loc 1 204 15
 522 01d4 5340     		eors	r3, r3, r2
 523 01d6 DAB2     		uxtb	r2, r3
 524              		.loc 1 204 59
 525 01d8 97F82530 		ldrb	r3, [r7, #37]	@ zero_extendqisi2
 526              		.loc 1 204 15
 527 01dc 5340     		eors	r3, r3, r2
 528 01de DBB2     		uxtb	r3, r3
 529 01e0 87F82630 		strb	r3, [r7, #38]
 205:../../lib/bsrfid/cards/picc.c **** 
 206:../../lib/bsrfid/cards/picc.c **** 				sendCRC = true;
 530              		.loc 1 206 13
 531 01e4 0123     		movs	r3, #1
 532 01e6 87F82F30 		strb	r3, [r7, #47]
 207:../../lib/bsrfid/cards/picc.c **** 
 208:../../lib/bsrfid/cards/picc.c **** 				txLastBits = 0; // 0 => All 8 bits are valid.
 533              		.loc 1 208 16
 534 01ea 0023     		movs	r3, #0
 535 01ec FB77     		strb	r3, [r7, #31]
 209:../../lib/bsrfid/cards/picc.c **** 				bufferUsed = 7;
 536              		.loc 1 209 16
ARM GAS  /tmp/cc7qBfpH.s 			page 14


 537 01ee 0723     		movs	r3, #7
 538 01f0 87F83730 		strb	r3, [r7, #55]
 210:../../lib/bsrfid/cards/picc.c **** 				// Store response in the last 3 uint8_ts of buffer (BCC and CRC_A - not needed after tx)
 211:../../lib/bsrfid/cards/picc.c **** 				responseBuffer = &buffer[6];
 539              		.loc 1 211 20
 540 01f4 07F12003 		add	r3, r7, #32
 541 01f8 0633     		adds	r3, r3, #6
 542 01fa 3B63     		str	r3, [r7, #48]
 212:../../lib/bsrfid/cards/picc.c **** 				responseLength = 3;
 543              		.loc 1 212 20
 544 01fc 0323     		movs	r3, #3
 545 01fe BB61     		str	r3, [r7, #24]
 546 0200 3CE0     		b	.L40
 547              	.L39:
 213:../../lib/bsrfid/cards/picc.c **** 			} else { // This is an ANTICOLLISION.
 214:../../lib/bsrfid/cards/picc.c **** 					 //Serial.print(F("ANTICOLLISION: currentLevelKnownBits=")); Serial.println(currentLevelKnownB
 215:../../lib/bsrfid/cards/picc.c **** 				txLastBits = currentLevelKnownBits % 8;
 548              		.loc 1 215 16
 549 0202 97F93830 		ldrsb	r3, [r7, #56]
 550 0206 5A42     		rsbs	r2, r3, #0
 551 0208 03F00703 		and	r3, r3, #7
 552 020c 02F00702 		and	r2, r2, #7
 553 0210 58BF     		it	pl
 554 0212 5342     		rsbpl	r3, r2, #0
 555 0214 5BB2     		sxtb	r3, r3
 556 0216 DBB2     		uxtb	r3, r3
 557 0218 FB77     		strb	r3, [r7, #31]
 216:../../lib/bsrfid/cards/picc.c **** 				count = currentLevelKnownBits / 8;// Number of whole uint8_ts in the UID part.
 558              		.loc 1 216 11
 559 021a 97F93830 		ldrsb	r3, [r7, #56]
 560 021e 002B     		cmp	r3, #0
 561 0220 00DA     		bge	.L41
 562 0222 0733     		adds	r3, r3, #7
 563              	.L41:
 564 0224 DB10     		asrs	r3, r3, #3
 565 0226 5BB2     		sxtb	r3, r3
 566 0228 87F83B30 		strb	r3, [r7, #59]
 217:../../lib/bsrfid/cards/picc.c **** 				index = 2 + count;// Number of whole uint8_ts: SEL + NVB + UIDs
 567              		.loc 1 217 11
 568 022c 97F83B30 		ldrb	r3, [r7, #59]
 569 0230 0233     		adds	r3, r3, #2
 570 0232 87F83A30 		strb	r3, [r7, #58]
 218:../../lib/bsrfid/cards/picc.c **** 				buffer[1] = (index << 4) + txLastBits;// NVB - Number of Valid Bits
 571              		.loc 1 218 24
 572 0236 97F83A30 		ldrb	r3, [r7, #58]
 573 023a 1B01     		lsls	r3, r3, #4
 574 023c DAB2     		uxtb	r2, r3
 575              		.loc 1 218 30
 576 023e FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 577 0240 1344     		add	r3, r3, r2
 578 0242 DBB2     		uxtb	r3, r3
 579              		.loc 1 218 15
 580 0244 87F82130 		strb	r3, [r7, #33]
 219:../../lib/bsrfid/cards/picc.c **** 				bufferUsed = index + (txLastBits ? 1 : 0);
 581              		.loc 1 219 42
 582 0248 FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 583 024a 002B     		cmp	r3, #0
ARM GAS  /tmp/cc7qBfpH.s 			page 15


 584 024c 14BF     		ite	ne
 585 024e 0123     		movne	r3, #1
 586 0250 0023     		moveq	r3, #0
 587 0252 DBB2     		uxtb	r3, r3
 588 0254 1A46     		mov	r2, r3
 589              		.loc 1 219 16
 590 0256 97F83A30 		ldrb	r3, [r7, #58]
 591 025a 1344     		add	r3, r3, r2
 592 025c 87F83730 		strb	r3, [r7, #55]
 220:../../lib/bsrfid/cards/picc.c **** 				// Store response in the unused part of buffer
 221:../../lib/bsrfid/cards/picc.c **** 				responseBuffer = &buffer[index];
 593              		.loc 1 221 29
 594 0260 97F83A30 		ldrb	r3, [r7, #58]	@ zero_extendqisi2
 595              		.loc 1 221 20
 596 0264 07F12002 		add	r2, r7, #32
 597 0268 1344     		add	r3, r3, r2
 598 026a 3B63     		str	r3, [r7, #48]
 222:../../lib/bsrfid/cards/picc.c **** 				responseLength = sizeof(buffer) - index;
 599              		.loc 1 222 37
 600 026c 97F83A30 		ldrb	r3, [r7, #58]	@ zero_extendqisi2
 601 0270 C3F10903 		rsb	r3, r3, #9
 602              		.loc 1 222 20
 603 0274 BB61     		str	r3, [r7, #24]
 223:../../lib/bsrfid/cards/picc.c **** 				sendCRC = false;
 604              		.loc 1 223 13
 605 0276 0023     		movs	r3, #0
 606 0278 87F82F30 		strb	r3, [r7, #47]
 607              	.L40:
 224:../../lib/bsrfid/cards/picc.c **** 			}
 225:../../lib/bsrfid/cards/picc.c **** 
 226:../../lib/bsrfid/cards/picc.c **** 			rxAlign = txLastBits;// Having a separate variable is overkill. But it makes the next line easie
 608              		.loc 1 226 12
 609 027c FB7F     		ldrb	r3, [r7, #31]
 610 027e 87F82C30 		strb	r3, [r7, #44]
 227:../../lib/bsrfid/cards/picc.c **** 			uint8_t collisionPos;
 228:../../lib/bsrfid/cards/picc.c **** 			// Transmit the buffer and receive the response.
 229:../../lib/bsrfid/cards/picc.c **** 			result = pdc->TransceiveData(pdc, buffer, bufferUsed,
 611              		.loc 1 229 16
 612 0282 FB68     		ldr	r3, [r7, #12]
 613 0284 DC68     		ldr	r4, [r3, #12]
 614              		.loc 1 229 13
 615 0286 97F83720 		ldrb	r2, [r7, #55]	@ zero_extendqisi2
 616 028a 07F12001 		add	r1, r7, #32
 617 028e 0023     		movs	r3, #0
 618 0290 0593     		str	r3, [sp, #20]
 619 0292 97F82F30 		ldrb	r3, [r7, #47]	@ zero_extendqisi2
 620 0296 0493     		str	r3, [sp, #16]
 621 0298 07F11703 		add	r3, r7, #23
 622 029c 0393     		str	r3, [sp, #12]
 623 029e 97F82C30 		ldrb	r3, [r7, #44]	@ zero_extendqisi2
 624 02a2 0293     		str	r3, [sp, #8]
 625 02a4 07F11F03 		add	r3, r7, #31
 626 02a8 0193     		str	r3, [sp, #4]
 627 02aa 07F11803 		add	r3, r7, #24
 628 02ae 0093     		str	r3, [sp]
 629 02b0 3B6B     		ldr	r3, [r7, #48]
 630 02b2 F868     		ldr	r0, [r7, #12]
ARM GAS  /tmp/cc7qBfpH.s 			page 16


 631 02b4 A047     		blx	r4
 632              	.LVL1:
 633 02b6 0346     		mov	r3, r0
 634              		.loc 1 229 11
 635 02b8 87F82B30 		strb	r3, [r7, #43]
 230:../../lib/bsrfid/cards/picc.c **** 					responseBuffer, &responseLength, &txLastBits, rxAlign,
 231:../../lib/bsrfid/cards/picc.c **** 					&collisionPos, sendCRC, false);
 232:../../lib/bsrfid/cards/picc.c **** 			if (result == STATUS_COLLISION) {
 636              		.loc 1 232 7
 637 02bc 97F92B30 		ldrsb	r3, [r7, #43]
 638 02c0 13F1030F 		cmn	r3, #3
 639 02c4 4ED1     		bne	.L42
 233:../../lib/bsrfid/cards/picc.c **** 
 234:../../lib/bsrfid/cards/picc.c **** 				if (collisionPos <= currentLevelKnownBits) { // No progress - should not happen
 640              		.loc 1 234 22
 641 02c6 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 642 02c8 1A46     		mov	r2, r3
 643 02ca 97F93830 		ldrsb	r3, [r7, #56]
 644              		.loc 1 234 8
 645 02ce 9A42     		cmp	r2, r3
 646 02d0 02DC     		bgt	.L43
 235:../../lib/bsrfid/cards/picc.c **** 					return STATUS_INTERNAL_ERROR;
 647              		.loc 1 235 13
 648 02d2 6FF00503 		mvn	r3, #5
 649 02d6 C3E0     		b	.L60
 650              	.L43:
 236:../../lib/bsrfid/cards/picc.c **** 				}
 237:../../lib/bsrfid/cards/picc.c **** 				// Choose the PICC with the bit set.
 238:../../lib/bsrfid/cards/picc.c **** 				currentLevelKnownBits = collisionPos;
 651              		.loc 1 238 27
 652 02d8 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 653 02da 87F83830 		strb	r3, [r7, #56]
 239:../../lib/bsrfid/cards/picc.c **** 				count = currentLevelKnownBits % 8; // The bit to modify
 654              		.loc 1 239 11
 655 02de 97F93830 		ldrsb	r3, [r7, #56]
 656 02e2 5A42     		rsbs	r2, r3, #0
 657 02e4 03F00703 		and	r3, r3, #7
 658 02e8 02F00702 		and	r2, r2, #7
 659 02ec 58BF     		it	pl
 660 02ee 5342     		rsbpl	r3, r2, #0
 661 02f0 5BB2     		sxtb	r3, r3
 662 02f2 87F83B30 		strb	r3, [r7, #59]
 240:../../lib/bsrfid/cards/picc.c **** 				checkBit = (currentLevelKnownBits - 1) % 8;
 663              		.loc 1 240 39
 664 02f6 97F93830 		ldrsb	r3, [r7, #56]
 665 02fa 013B     		subs	r3, r3, #1
 666              		.loc 1 240 44
 667 02fc 5A42     		rsbs	r2, r3, #0
 668 02fe 03F00703 		and	r3, r3, #7
 669 0302 02F00702 		and	r2, r2, #7
 670 0306 58BF     		it	pl
 671 0308 5342     		rsbpl	r3, r2, #0
 672              		.loc 1 240 14
 673 030a 87F82A30 		strb	r3, [r7, #42]
 241:../../lib/bsrfid/cards/picc.c **** 				index = 1 + (currentLevelKnownBits / 8) + (count ? 1 : 0); // First uint8_t is index 0.
 674              		.loc 1 241 45
 675 030e 97F93830 		ldrsb	r3, [r7, #56]
ARM GAS  /tmp/cc7qBfpH.s 			page 17


 676 0312 002B     		cmp	r3, #0
 677 0314 00DA     		bge	.L45
 678 0316 0733     		adds	r3, r3, #7
 679              	.L45:
 680 0318 DB10     		asrs	r3, r3, #3
 681 031a 5BB2     		sxtb	r3, r3
 682 031c DBB2     		uxtb	r3, r3
 683              		.loc 1 241 58
 684 031e 97F83B20 		ldrb	r2, [r7, #59]	@ zero_extendqisi2
 685 0322 002A     		cmp	r2, #0
 686 0324 14BF     		ite	ne
 687 0326 0122     		movne	r2, #1
 688 0328 0022     		moveq	r2, #0
 689 032a D2B2     		uxtb	r2, r2
 690              		.loc 1 241 45
 691 032c 1344     		add	r3, r3, r2
 692 032e DBB2     		uxtb	r3, r3
 693              		.loc 1 241 11
 694 0330 0133     		adds	r3, r3, #1
 695 0332 87F83A30 		strb	r3, [r7, #58]
 242:../../lib/bsrfid/cards/picc.c **** 				buffer[index] |= (1 << checkBit);
 696              		.loc 1 242 19
 697 0336 97F83A30 		ldrb	r3, [r7, #58]	@ zero_extendqisi2
 698 033a 4033     		adds	r3, r3, #64
 699 033c 3B44     		add	r3, r3, r7
 700 033e 13F8203C 		ldrb	r3, [r3, #-32]	@ zero_extendqisi2
 701 0342 5AB2     		sxtb	r2, r3
 702              		.loc 1 242 25
 703 0344 97F82A30 		ldrb	r3, [r7, #42]	@ zero_extendqisi2
 704 0348 0121     		movs	r1, #1
 705 034a 01FA03F3 		lsl	r3, r1, r3
 706              		.loc 1 242 19
 707 034e 5BB2     		sxtb	r3, r3
 708 0350 1343     		orrs	r3, r3, r2
 709 0352 5AB2     		sxtb	r2, r3
 710 0354 97F83A30 		ldrb	r3, [r7, #58]	@ zero_extendqisi2
 711 0358 D2B2     		uxtb	r2, r2
 712 035a 4033     		adds	r3, r3, #64
 713 035c 3B44     		add	r3, r3, r7
 714 035e 03F8202C 		strb	r2, [r3, #-32]
 715 0362 11E0     		b	.L38
 716              	.L42:
 243:../../lib/bsrfid/cards/picc.c **** 			} else if (result != STATUS_OK) {
 717              		.loc 1 243 14
 718 0364 97F92B30 		ldrsb	r3, [r7, #43]
 719 0368 002B     		cmp	r3, #0
 720 036a 02D0     		beq	.L47
 244:../../lib/bsrfid/cards/picc.c **** 				return result;
 721              		.loc 1 244 12
 722 036c 97F92B30 		ldrsb	r3, [r7, #43]
 723 0370 76E0     		b	.L60
 724              	.L47:
 245:../../lib/bsrfid/cards/picc.c **** 			} else { // STATUS_OK
 246:../../lib/bsrfid/cards/picc.c **** 				if (currentLevelKnownBits >= 32) { // This was a SELECT.
 725              		.loc 1 246 8
 726 0372 97F93830 		ldrsb	r3, [r7, #56]
 727 0376 1F2B     		cmp	r3, #31
ARM GAS  /tmp/cc7qBfpH.s 			page 18


 728 0378 03DD     		ble	.L48
 247:../../lib/bsrfid/cards/picc.c **** 					selectDone = true; // No more anticollision
 729              		.loc 1 247 17
 730 037a 0123     		movs	r3, #1
 731 037c 87F83E30 		strb	r3, [r7, #62]
 732 0380 02E0     		b	.L38
 733              	.L48:
 248:../../lib/bsrfid/cards/picc.c **** 					// We continue below outside the while.
 249:../../lib/bsrfid/cards/picc.c **** 				} else { // This was an ANTICOLLISION.
 250:../../lib/bsrfid/cards/picc.c **** 						 // We now have all 32 bits of the UID in this Cascade Level
 251:../../lib/bsrfid/cards/picc.c **** 					currentLevelKnownBits = 32;
 734              		.loc 1 251 28
 735 0382 2023     		movs	r3, #32
 736 0384 87F83830 		strb	r3, [r7, #56]
 737              	.L38:
 738              	.LBE4:
 198:../../lib/bsrfid/cards/picc.c **** 			// Find out how many bits and uint8_ts to send and receive.
 739              		.loc 1 198 10
 740 0388 97F83E30 		ldrb	r3, [r7, #62]
 741 038c 83F00103 		eor	r3, r3, #1
 742 0390 DBB2     		uxtb	r3, r3
 743 0392 002B     		cmp	r3, #0
 744 0394 7FF40FAF 		bne	.L49
 252:../../lib/bsrfid/cards/picc.c **** 					// Run loop again to do the SELECT.
 253:../../lib/bsrfid/cards/picc.c **** 				}
 254:../../lib/bsrfid/cards/picc.c **** 			}
 255:../../lib/bsrfid/cards/picc.c **** 		} // End of while (!selectDone)
 256:../../lib/bsrfid/cards/picc.c **** 
 257:../../lib/bsrfid/cards/picc.c **** 		// We do not check the CBB - it was constructed by us above.
 258:../../lib/bsrfid/cards/picc.c **** 
 259:../../lib/bsrfid/cards/picc.c **** 		// Copy the found UID uint8_ts from buffer[] to uid->uidByte[]
 260:../../lib/bsrfid/cards/picc.c **** 		index = (buffer[2] == PICC_CMD_CT) ? 3 : 2; // source index in buffer[]
 745              		.loc 1 260 18
 746 0398 97F82230 		ldrb	r3, [r7, #34]	@ zero_extendqisi2
 747              		.loc 1 260 9
 748 039c 882B     		cmp	r3, #136
 749 039e 01D1     		bne	.L50
 750              		.loc 1 260 9 is_stmt 0 discriminator 1
 751 03a0 0323     		movs	r3, #3
 752 03a2 00E0     		b	.L51
 753              	.L50:
 754              		.loc 1 260 9 discriminator 2
 755 03a4 0223     		movs	r3, #2
 756              	.L51:
 757              		.loc 1 260 9 discriminator 4
 758 03a6 87F83A30 		strb	r3, [r7, #58]
 261:../../lib/bsrfid/cards/picc.c **** 		BytesToCopy = (buffer[2] == PICC_CMD_CT) ? 3 : 4;
 759              		.loc 1 261 24 is_stmt 1 discriminator 4
 760 03aa 97F82230 		ldrb	r3, [r7, #34]	@ zero_extendqisi2
 761              		.loc 1 261 15 discriminator 4
 762 03ae 882B     		cmp	r3, #136
 763 03b0 01D1     		bne	.L52
 764              		.loc 1 261 15 is_stmt 0 discriminator 1
 765 03b2 0323     		movs	r3, #3
 766 03b4 00E0     		b	.L53
 767              	.L52:
 768              		.loc 1 261 15 discriminator 2
ARM GAS  /tmp/cc7qBfpH.s 			page 19


 769 03b6 0423     		movs	r3, #4
 770              	.L53:
 771              		.loc 1 261 15 discriminator 4
 772 03b8 87F82E30 		strb	r3, [r7, #46]
 262:../../lib/bsrfid/cards/picc.c **** 		for (count = 0; count < BytesToCopy; count++) {
 773              		.loc 1 262 14 is_stmt 1 discriminator 4
 774 03bc 0023     		movs	r3, #0
 775 03be 87F83B30 		strb	r3, [r7, #59]
 776              		.loc 1 262 3 discriminator 4
 777 03c2 18E0     		b	.L54
 778              	.L55:
 263:../../lib/bsrfid/cards/picc.c **** 			picc->uidByte[uidIndex + count] = buffer[index++];
 779              		.loc 1 263 50 discriminator 3
 780 03c4 97F83A30 		ldrb	r3, [r7, #58]	@ zero_extendqisi2
 781 03c8 5A1C     		adds	r2, r3, #1
 782 03ca 87F83A20 		strb	r2, [r7, #58]
 783 03ce 1946     		mov	r1, r3
 784              		.loc 1 263 27 discriminator 3
 785 03d0 97F83920 		ldrb	r2, [r7, #57]	@ zero_extendqisi2
 786 03d4 97F83B30 		ldrb	r3, [r7, #59]	@ zero_extendqisi2
 787 03d8 1344     		add	r3, r3, r2
 788              		.loc 1 263 44 discriminator 3
 789 03da 01F14002 		add	r2, r1, #64
 790 03de 3A44     		add	r2, r2, r7
 791 03e0 12F8201C 		ldrb	r1, [r2, #-32]	@ zero_extendqisi2
 792              		.loc 1 263 36 discriminator 3
 793 03e4 BA68     		ldr	r2, [r7, #8]
 794 03e6 1344     		add	r3, r3, r2
 795 03e8 0A46     		mov	r2, r1
 796 03ea 9A70     		strb	r2, [r3, #2]
 262:../../lib/bsrfid/cards/picc.c **** 		for (count = 0; count < BytesToCopy; count++) {
 797              		.loc 1 262 45 discriminator 3
 798 03ec 97F83B30 		ldrb	r3, [r7, #59]	@ zero_extendqisi2
 799 03f0 0133     		adds	r3, r3, #1
 800 03f2 87F83B30 		strb	r3, [r7, #59]
 801              	.L54:
 262:../../lib/bsrfid/cards/picc.c **** 		for (count = 0; count < BytesToCopy; count++) {
 802              		.loc 1 262 25 discriminator 1
 803 03f6 97F83B20 		ldrb	r2, [r7, #59]	@ zero_extendqisi2
 804 03fa 97F82E30 		ldrb	r3, [r7, #46]	@ zero_extendqisi2
 805 03fe 9A42     		cmp	r2, r3
 806 0400 E0D3     		bcc	.L55
 264:../../lib/bsrfid/cards/picc.c **** 		}
 265:../../lib/bsrfid/cards/picc.c **** 
 266:../../lib/bsrfid/cards/picc.c **** 		// Check response SAK (Select Acknowledge)
 267:../../lib/bsrfid/cards/picc.c **** 		if (responseLength != 3 || txLastBits != 0) { // SAK must be exactly 24 bits (1 uint8_t + CRC_A).
 807              		.loc 1 267 22
 808 0402 BB69     		ldr	r3, [r7, #24]
 809              		.loc 1 267 6
 810 0404 032B     		cmp	r3, #3
 811 0406 02D1     		bne	.L56
 812              		.loc 1 267 41 discriminator 1
 813 0408 FB7F     		ldrb	r3, [r7, #31]	@ zero_extendqisi2
 814              		.loc 1 267 27 discriminator 1
 815 040a 002B     		cmp	r3, #0
 816 040c 02D0     		beq	.L57
 817              	.L56:
ARM GAS  /tmp/cc7qBfpH.s 			page 20


 268:../../lib/bsrfid/cards/picc.c **** 			return STATUS_ERROR;
 818              		.loc 1 268 11
 819 040e 4FF0FF33 		mov	r3, #-1
 820 0412 25E0     		b	.L60
 821              	.L57:
 269:../../lib/bsrfid/cards/picc.c **** 		}
 270:../../lib/bsrfid/cards/picc.c **** 
 271:../../lib/bsrfid/cards/picc.c **** 		/*
 272:../../lib/bsrfid/cards/picc.c **** 		 // Verify CRC_A - do our own calculation and store the control in buffer[2..3] - those uint8_ts 
 273:../../lib/bsrfid/cards/picc.c **** 		 result = RC52X_CalculateCRC(rc52x, responseBuffer, 1, &buffer[2]);
 274:../../lib/bsrfid/cards/picc.c **** 		 if (result != STATUS_OK) {
 275:../../lib/bsrfid/cards/picc.c **** 		 return result;
 276:../../lib/bsrfid/cards/picc.c **** 		 }
 277:../../lib/bsrfid/cards/picc.c **** 
 278:../../lib/bsrfid/cards/picc.c **** 		if ((buffer[2] != responseBuffer[1])
 279:../../lib/bsrfid/cards/picc.c **** 				|| (buffer[3] != responseBuffer[2])) {
 280:../../lib/bsrfid/cards/picc.c **** 			return STATUS_CRC_WRONG;
 281:../../lib/bsrfid/cards/picc.c **** 		}
 282:../../lib/bsrfid/cards/picc.c **** 		 */
 283:../../lib/bsrfid/cards/picc.c **** 
 284:../../lib/bsrfid/cards/picc.c **** 		if (responseBuffer[0] & 0x04) { // Cascade bit set - UID not complete yes
 822              		.loc 1 284 21
 823 0414 3B6B     		ldr	r3, [r7, #48]
 824 0416 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 825              		.loc 1 284 25
 826 0418 03F00403 		and	r3, r3, #4
 827              		.loc 1 284 6
 828 041c 002B     		cmp	r3, #0
 829 041e 05D0     		beq	.L58
 285:../../lib/bsrfid/cards/picc.c **** 			cascadeLevel++;
 830              		.loc 1 285 16
 831 0420 97F83C30 		ldrb	r3, [r7, #60]	@ zero_extendqisi2
 832 0424 0133     		adds	r3, r3, #1
 833 0426 87F83C30 		strb	r3, [r7, #60]
 834 042a 06E0     		b	.L18
 835              	.L58:
 286:../../lib/bsrfid/cards/picc.c **** 		} else {
 287:../../lib/bsrfid/cards/picc.c **** 			uidComplete = true;
 836              		.loc 1 287 16
 837 042c 0123     		movs	r3, #1
 838 042e 87F83F30 		strb	r3, [r7, #63]
 288:../../lib/bsrfid/cards/picc.c **** 			picc->sak.as_uint8 = responseBuffer[0];
 839              		.loc 1 288 39
 840 0432 3B6B     		ldr	r3, [r7, #48]
 841 0434 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 842              		.loc 1 288 23
 843 0436 BB68     		ldr	r3, [r7, #8]
 844 0438 5A73     		strb	r2, [r3, #13]
 845              	.L18:
 846              	.LBE2:
 144:../../lib/bsrfid/cards/picc.c **** 		// Set the Cascade Level in the SEL uint8_t, find out if we need to use the Cascade Tag in uint8_
 847              		.loc 1 144 9
 848 043a 97F83F30 		ldrb	r3, [r7, #63]
 849 043e 83F00103 		eor	r3, r3, #1
 850 0442 DBB2     		uxtb	r3, r3
 851 0444 002B     		cmp	r3, #0
 852 0446 7FF4EFAD 		bne	.L59
ARM GAS  /tmp/cc7qBfpH.s 			page 21


 289:../../lib/bsrfid/cards/picc.c **** 		}
 290:../../lib/bsrfid/cards/picc.c **** 	} // End of while (!uidComplete)
 291:../../lib/bsrfid/cards/picc.c **** 
 292:../../lib/bsrfid/cards/picc.c **** 	// Set correct uid->size
 293:../../lib/bsrfid/cards/picc.c **** 	picc->size = 3 * cascadeLevel + 1;
 853              		.loc 1 293 32
 854 044a 97F83C30 		ldrb	r3, [r7, #60]
 855 044e 1A46     		mov	r2, r3
 856 0450 5200     		lsls	r2, r2, #1
 857 0452 1344     		add	r3, r3, r2
 858 0454 DBB2     		uxtb	r3, r3
 859 0456 0133     		adds	r3, r3, #1
 860 0458 DAB2     		uxtb	r2, r3
 861              		.loc 1 293 13
 862 045a BB68     		ldr	r3, [r7, #8]
 863 045c 5A70     		strb	r2, [r3, #1]
 294:../../lib/bsrfid/cards/picc.c **** 
 295:../../lib/bsrfid/cards/picc.c **** 	return STATUS_OK;
 864              		.loc 1 295 9
 865 045e 0023     		movs	r3, #0
 866              	.L60:
 296:../../lib/bsrfid/cards/picc.c **** } // End PICC_Select()
 867              		.loc 1 296 1 discriminator 1
 868 0460 1846     		mov	r0, r3
 869 0462 4437     		adds	r7, r7, #68
 870              		.cfi_def_cfa_offset 12
 871 0464 BD46     		mov	sp, r7
 872              		.cfi_def_cfa_register 13
 873              		@ sp needed
 874 0466 90BD     		pop	{r4, r7, pc}
 875              		.cfi_endproc
 876              	.LFE3:
 878              		.section	.text.PICC_HaltA,"ax",%progbits
 879              		.align	1
 880              		.global	PICC_HaltA
 881              		.syntax unified
 882              		.thumb
 883              		.thumb_func
 884              		.fpu softvfp
 886              	PICC_HaltA:
 887              	.LFB4:
 297:../../lib/bsrfid/cards/picc.c **** 
 298:../../lib/bsrfid/cards/picc.c **** /**
 299:../../lib/bsrfid/cards/picc.c ****  * Instructs a PICC in state ACTIVE(*) to go to state HALT.
 300:../../lib/bsrfid/cards/picc.c ****  *
 301:../../lib/bsrfid/cards/picc.c ****  * @return STATUS_OK on success, STATUS_??? otherwise.
 302:../../lib/bsrfid/cards/picc.c ****  */
 303:../../lib/bsrfid/cards/picc.c **** rc52x_result_t PICC_HaltA(bs_pdc_t *pdc) {
 888              		.loc 1 303 42
 889              		.cfi_startproc
 890              		@ args = 0, pretend = 0, frame = 16
 891              		@ frame_needed = 1, uses_anonymous_args = 0
 892 0000 80B5     		push	{r7, lr}
 893              		.cfi_def_cfa_offset 8
 894              		.cfi_offset 7, -8
 895              		.cfi_offset 14, -4
 896 0002 88B0     		sub	sp, sp, #32
ARM GAS  /tmp/cc7qBfpH.s 			page 22


 897              		.cfi_def_cfa_offset 40
 898 0004 04AF     		add	r7, sp, #16
 899              		.cfi_def_cfa 7, 24
 900 0006 7860     		str	r0, [r7, #4]
 304:../../lib/bsrfid/cards/picc.c **** 	rc52x_result_t result;
 305:../../lib/bsrfid/cards/picc.c **** 	uint8_t buffer[4];
 306:../../lib/bsrfid/cards/picc.c **** 
 307:../../lib/bsrfid/cards/picc.c **** 	// Build command buffer
 308:../../lib/bsrfid/cards/picc.c **** 	buffer[0] = PICC_CMD_HLTA;
 901              		.loc 1 308 12
 902 0008 5023     		movs	r3, #80
 903 000a 3B72     		strb	r3, [r7, #8]
 309:../../lib/bsrfid/cards/picc.c **** 	buffer[1] = 0;
 904              		.loc 1 309 12
 905 000c 0023     		movs	r3, #0
 906 000e 7B72     		strb	r3, [r7, #9]
 310:../../lib/bsrfid/cards/picc.c **** 	// Calculate CRC_A
 311:../../lib/bsrfid/cards/picc.c **** 	result = RC52X_CalculateCRC(pdc, buffer, 2, &buffer[2]);
 907              		.loc 1 311 11
 908 0010 07F10803 		add	r3, r7, #8
 909 0014 0233     		adds	r3, r3, #2
 910 0016 07F10801 		add	r1, r7, #8
 911 001a 0222     		movs	r2, #2
 912 001c 7868     		ldr	r0, [r7, #4]
 913 001e FFF7FEFF 		bl	RC52X_CalculateCRC
 914 0022 0346     		mov	r3, r0
 915              		.loc 1 311 9
 916 0024 FB73     		strb	r3, [r7, #15]
 312:../../lib/bsrfid/cards/picc.c **** 	if (result != STATUS_OK) {
 917              		.loc 1 312 5
 918 0026 97F90F30 		ldrsb	r3, [r7, #15]
 919 002a 002B     		cmp	r3, #0
 920 002c 02D0     		beq	.L62
 313:../../lib/bsrfid/cards/picc.c **** 		return result;
 921              		.loc 1 313 10
 922 002e 97F90F30 		ldrsb	r3, [r7, #15]
 923 0032 20E0     		b	.L66
 924              	.L62:
 314:../../lib/bsrfid/cards/picc.c **** 	}
 315:../../lib/bsrfid/cards/picc.c **** 
 316:../../lib/bsrfid/cards/picc.c **** 	// Send the command.
 317:../../lib/bsrfid/cards/picc.c **** 	// The standard says:
 318:../../lib/bsrfid/cards/picc.c **** 	//		If the PICC responds with any modulation during a period of 1 ms after the end of the frame co
 319:../../lib/bsrfid/cards/picc.c **** 	//		HLTA command, this response shall be interpreted as 'not acknowledge'.
 320:../../lib/bsrfid/cards/picc.c **** 	// We interpret that this way: Only STATUS_TIMEOUT is a success.
 321:../../lib/bsrfid/cards/picc.c **** 	result = RC52X_TransceiveData(pdc, buffer, sizeof(buffer), NULL, 0, NULL, 0,
 925              		.loc 1 321 11
 926 0034 07F10801 		add	r1, r7, #8
 927 0038 0023     		movs	r3, #0
 928 003a 0393     		str	r3, [sp, #12]
 929 003c 0023     		movs	r3, #0
 930 003e 0293     		str	r3, [sp, #8]
 931 0040 0023     		movs	r3, #0
 932 0042 0193     		str	r3, [sp, #4]
 933 0044 0023     		movs	r3, #0
 934 0046 0093     		str	r3, [sp]
 935 0048 0023     		movs	r3, #0
ARM GAS  /tmp/cc7qBfpH.s 			page 23


 936 004a 0422     		movs	r2, #4
 937 004c 7868     		ldr	r0, [r7, #4]
 938 004e FFF7FEFF 		bl	RC52X_TransceiveData
 939 0052 0346     		mov	r3, r0
 940              		.loc 1 321 9
 941 0054 FB73     		strb	r3, [r7, #15]
 322:../../lib/bsrfid/cards/picc.c **** 			false);
 323:../../lib/bsrfid/cards/picc.c **** 	if (result == STATUS_TIMEOUT) {
 942              		.loc 1 323 5
 943 0056 97F90F30 		ldrsb	r3, [r7, #15]
 944 005a 13F1040F 		cmn	r3, #4
 945 005e 01D1     		bne	.L64
 324:../../lib/bsrfid/cards/picc.c **** 		return STATUS_OK;
 946              		.loc 1 324 10
 947 0060 0023     		movs	r3, #0
 948 0062 08E0     		b	.L66
 949              	.L64:
 325:../../lib/bsrfid/cards/picc.c **** 	}
 326:../../lib/bsrfid/cards/picc.c **** 	if (result == STATUS_OK) { // That is ironically NOT ok in this case ;-)
 950              		.loc 1 326 5
 951 0064 97F90F30 		ldrsb	r3, [r7, #15]
 952 0068 002B     		cmp	r3, #0
 953 006a 02D1     		bne	.L65
 327:../../lib/bsrfid/cards/picc.c **** 		return STATUS_ERROR;
 954              		.loc 1 327 10
 955 006c 4FF0FF33 		mov	r3, #-1
 956 0070 01E0     		b	.L66
 957              	.L65:
 328:../../lib/bsrfid/cards/picc.c **** 	}
 329:../../lib/bsrfid/cards/picc.c **** 	return result;
 958              		.loc 1 329 9
 959 0072 97F90F30 		ldrsb	r3, [r7, #15]
 960              	.L66:
 330:../../lib/bsrfid/cards/picc.c **** } // End PICC_HaltA()
 961              		.loc 1 330 1 discriminator 1
 962 0076 1846     		mov	r0, r3
 963 0078 1037     		adds	r7, r7, #16
 964              		.cfi_def_cfa_offset 8
 965 007a BD46     		mov	sp, r7
 966              		.cfi_def_cfa_register 13
 967              		@ sp needed
 968 007c 80BD     		pop	{r7, pc}
 969              		.cfi_endproc
 970              	.LFE4:
 972              		.text
 973              	.Letext0:
 974              		.file 2 "/usr/lib/gcc/arm-none-eabi/11.2.0/include/stddef.h"
 975              		.file 3 "/usr/arm-none-eabi/include/machine/_default_types.h"
 976              		.file 4 "/usr/arm-none-eabi/include/sys/_stdint.h"
 977              		.file 5 "../../lib/bsrfid/cards/iso14443a.h"
 978              		.file 6 "../../lib/bsrfid/drivers/pdc.h"
 979              		.file 7 "../../lib/bsrfid/cards/picc.h"
ARM GAS  /tmp/cc7qBfpH.s 			page 24


DEFINED SYMBOLS
                            *ABS*:0000000000000000 picc.c
     /tmp/cc7qBfpH.s:16     .text.PICC_RequestA:0000000000000000 $t
     /tmp/cc7qBfpH.s:24     .text.PICC_RequestA:0000000000000000 PICC_RequestA
     /tmp/cc7qBfpH.s:134    .text.PICC_REQA_or_WUPA:0000000000000000 PICC_REQA_or_WUPA
     /tmp/cc7qBfpH.s:69     .text.PICC_WakeupA:0000000000000000 $t
     /tmp/cc7qBfpH.s:76     .text.PICC_WakeupA:0000000000000000 PICC_WakeupA
     /tmp/cc7qBfpH.s:127    .text.PICC_REQA_or_WUPA:0000000000000000 $t
     /tmp/cc7qBfpH.s:236    .text.PICC_Select:0000000000000000 $t
     /tmp/cc7qBfpH.s:243    .text.PICC_Select:0000000000000000 PICC_Select
     /tmp/cc7qBfpH.s:879    .text.PICC_HaltA:0000000000000000 $t
     /tmp/cc7qBfpH.s:886    .text.PICC_HaltA:0000000000000000 PICC_HaltA
                           .group:0000000000000000 wm4.0.1098e563ef56396ca346ad6c5e97276e
                           .group:0000000000000000 wm4.ieeefp.h.77.af21f134a392aadc2c66139cb51ca3a9
                           .group:0000000000000000 wm4._newlib_version.h.4.bfdf54b0af045d4a71376ae00f63a22c
                           .group:0000000000000000 wm4.newlib.h.18.1c9fedb6b3cd797cff253cc0fd593ef2
                           .group:0000000000000000 wm4.features.h.22.fad1cec3bc7ff06488171438dbdcfd02
                           .group:0000000000000000 wm4.config.h.224.c701144a7b0518c6ee9b9b5465b79f81
                           .group:0000000000000000 wm4._ansi.h.31.de524f58584151836e90d8620a16f8e8
                           .group:0000000000000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:0000000000000000 wm4.stddef.h.181.13772e73e5434e8cc4fafaaddad2b5da
                           .group:0000000000000000 wm4.stddef.h.39.cf3ebec0bc8c9e3d2f276a64e0fe5e7a
                           .group:0000000000000000 wm4._types.h.20.dd0d04dca3800a0d2a6129b87f3adbb2
                           .group:0000000000000000 wm4.stddef.h.155.3588ebfdd1e8c7ede80509bb9c3b8009
                           .group:0000000000000000 wm4._default_types.h.6.959254cf5f09734ea7516c89e8bb21bd
                           .group:0000000000000000 wm4._types.h.127.34941de1b2539d59d5cac00e0dd27a45
                           .group:0000000000000000 wm4.reent.h.17.e292bf8b0bec6c96e131a54347145a30
                           .group:0000000000000000 wm4.lock.h.2.1461d1fff82dffe8bfddc23307f6484f
                           .group:0000000000000000 wm4.reent.h.77.dcd6129ff07fe81bd5636db29abe53b2
                           .group:0000000000000000 wm4.cdefs.h.49.39045112216f6a021dbdffe3bf5accce
                           .group:0000000000000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:0000000000000000 wm4.stdlib.h.56.f4862cfbf4363a1db01842d5bdf72c18
                           .group:0000000000000000 wm4._intsup.h.10.48bafbb683905c4daa4565a85aeeb264
                           .group:0000000000000000 wm4._stdint.h.10.c24fa3af3bc1706662bb5593a907e841
                           .group:0000000000000000 wm4.stdint.h.23.d53047a68f4a85177f80b422d52785ed
                           .group:0000000000000000 wm4.stdbool.h.29.4a1c88fe569adb8d03217dd16982ca34

UNDEFINED SYMBOLS
RC52X_CalculateCRC
RC52X_TransceiveData
